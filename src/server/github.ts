import { Octokit } from '@octokit/rest';
import { ErrorLogEntry } from '../types';

export class GitHubService {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(token: string, owner: string, repo: string) {
    this.octokit = new Octokit({
      auth: token,
    });
    this.owner = owner;
    this.repo = repo;
  }

  async postErrorComment(prNumber: number, logs: ErrorLogEntry[]): Promise<void> {
    const body = this.formatErrorComment(logs);
    
    try {
      await this.octokit.rest.issues.createComment({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
        body,
      });
    } catch (error) {
      console.error('Failed to post GitHub comment:', error);
      throw new Error(`Failed to post comment to PR #${prNumber}: ${error}`);
    }
  }

  async findExistingErrorComment(prNumber: number): Promise<number | null> {
    try {
      const comments = await this.octokit.rest.issues.listComments({
        owner: this.owner,
        repo: this.repo,
        issue_number: prNumber,
      });

      const errorComment = comments.data.find(comment => 
        comment.body?.includes('üö® Error Report from Vercel Deployment')
      );

      return errorComment?.id || null;
    } catch (error) {
      console.error('Failed to find existing comments:', error);
      return null;
    }
  }

  async updateErrorComment(commentId: number, logs: ErrorLogEntry[]): Promise<void> {
    const body = this.formatErrorComment(logs);
    
    try {
      await this.octokit.rest.issues.updateComment({
        owner: this.owner,
        repo: this.repo,
        comment_id: commentId,
        body,
      });
    } catch (error) {
      console.error('Failed to update GitHub comment:', error);
      throw new Error(`Failed to update comment ${commentId}: ${error}`);
    }
  }

  async postOrUpdateErrorComment(prNumber: number, logs: ErrorLogEntry[]): Promise<void> {
    const existingCommentId = await this.findExistingErrorComment(prNumber);
    
    if (existingCommentId) {
      await this.updateErrorComment(existingCommentId, logs);
    } else {
      await this.postErrorComment(prNumber, logs);
    }
  }

  private formatErrorComment(logs: ErrorLogEntry[]): string {
    const errors = logs.filter(log => log.level === 'error');
    const warnings = logs.filter(log => log.level === 'warn');
    const infos = logs.filter(log => log.level === 'info' || log.level === 'log');

    const deployment = logs[0];
    const deviceInfo = deployment?.deviceInfo;

    let comment = `## üö® Error Report from Vercel Deployment

**Deployment URL:** ${deployment?.deploymentUrl || 'Unknown'}
**Environment:** ${deployment?.vercelEnv || 'Unknown'}
**Timestamp:** ${new Date().toISOString()}

### Device Information
- **Platform:** ${deviceInfo?.platform || 'Unknown'}
- **Viewport:** ${deviceInfo?.viewport?.width || 0}x${deviceInfo?.viewport?.height || 0}
- **Screen:** ${deviceInfo?.screen?.width || 0}x${deviceInfo?.screen?.height || 0}
- **Language:** ${deviceInfo?.language || 'Unknown'}
- **Timezone:** ${deviceInfo?.timezone || 'Unknown'}
- **Online:** ${deviceInfo?.onlineStatus ? 'Yes' : 'No'}

`;

    if (errors.length > 0) {
      comment += `### ‚ùå Errors (${errors.length})\n\n`;
      errors.forEach((error, index) => {
        comment += `#### Error ${index + 1}
**Message:** ${error.message}
**URL:** ${error.url}
**Time:** ${new Date(error.timestamp).toLocaleString()}

`;
        if (error.stack) {
          comment += `**Stack Trace:**
\`\`\`
${error.stack}
\`\`\`

`;
        }
      });
    }

    if (warnings.length > 0) {
      comment += `### ‚ö†Ô∏è Warnings (${warnings.length})\n\n`;
      warnings.slice(0, 5).forEach((warning, index) => {
        comment += `#### Warning ${index + 1}
**Message:** ${warning.message}
**URL:** ${warning.url}
**Time:** ${new Date(warning.timestamp).toLocaleString()}

`;
      });
      
      if (warnings.length > 5) {
        comment += `_... and ${warnings.length - 5} more warnings_\n\n`;
      }
    }

    if (infos.length > 0) {
      comment += `### ‚ÑπÔ∏è Info/Console Logs (${infos.length})\n\n`;
      comment += '<details><summary>View console logs</summary>\n\n';
      infos.slice(0, 10).forEach((info, index) => {
        comment += `**${index + 1}.** ${info.message} _(${new Date(info.timestamp).toLocaleString()})_\n`;
      });
      
      if (infos.length > 10) {
        comment += `_... and ${infos.length - 10} more log entries_\n`;
      }
      comment += '\n</details>\n\n';
    }

    comment += `---
*This comment was automatically generated by [PR Error Logger](https://github.com/your-org/pr-error-logger)*`;

    return comment;
  }

  async verifyAccess(): Promise<boolean> {
    try {
      await this.octokit.rest.repos.get({
        owner: this.owner,
        repo: this.repo,
      });
      return true;
    } catch (error) {
      console.error('GitHub access verification failed:', error);
      return false;
    }
  }
}